#include "cpptest.h"

/* CPPTEST_TEST_SUITE_CODE_BEGIN AdditionalIncludes */
#include "metaknowledge.h"
#include "player.h"
#include "game.h"
#include "tile.h"
/* CPPTEST_TEST_SUITE_CODE_END AdditionalIncludes */

CPPTEST_ADDITIONAL_STUB_FILES("/freeciv/common/stubs/autogenerated/auto_5c730dee.c;/freeciv/common/stubs/player_c_stubs.c;/freeciv/common/stubs/requirements_c_stubs.c;/freeciv/common/stubs/tile_c_stubs.c;/freeciv/common/stubs/city_c_stubs.c;/freeciv/common/stubs/diptreaty_c_stubs.c;/freeciv/common/stubs/genlist_h_stubs.c;");
CPPTEST_CONTEXT("../metaknowledge.c");

EXTERN_C_LINKAGE void metaknowledge_tests_testSuiteBegin(void);
EXTERN_C_LINKAGE int metaknowledge_tests_callTest(const char*);

CPPTEST_TEST_SUITE(metaknowledge_tests);
        CPPTEST_TEST_SUITE_SETUP(metaknowledge_tests_testSuiteSetUp);
        CPPTEST_TEST_SUITE_TEARDOWN(metaknowledge_tests_testSuiteTearDown);
CPPTEST_TEST_DS(metaknowledge_tests_mke_eval_req_test, CPPTEST_DS("__ds_step_autogen_f126681e_1749cf9d3f9"));
CPPTEST_TEST_DS(metaknowledge_tests_mke_eval_reqs_test, CPPTEST_DS("__ds_step_autogen_54a637d1_1749cf9d203"));
CPPTEST_TEST_DS(metaknowledge_tests_can_see_techs_of_target_test, CPPTEST_DS("__ds_step_autogen_d19e8df5_17541cb3c05"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UNITSTATE, CPPTEST_DS("__ds_step_autogen_24ee0df2_174a2a134b5"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINMOVES, CPPTEST_DS("__ds_step_autogen_ca0e468b_1749cf9cfeb"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTIVITY, CPPTEST_DS("__ds_step_autogen_b8227dea_175479f2d67"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UTFLAG_et_al, CPPTEST_DS("__ds_step_autogen_d0a8c4df_1749cf9d35d"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL, CPPTEST_DS("__ds_step_autogen_e877c15d_17541bf5ab9"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINSIZE, CPPTEST_DS("__ds_step_autogen_c476b6f8_174b15565b4"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE, CPPTEST_DS("__ds_step_autogen_c62ac974_17551cfa180"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPR_GENUS, CPPTEST_DS("__ds_step_autogen_f23e6a90_17547b7d7a7"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPROVEMENT, CPPTEST_DS("__ds_step_autogen_20c333fb_17547d76b3a"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_NATION_or_VUT_NATIONGROUP, CPPTEST_DS("__ds_step_autogen_5364bfcf_17528850c6c"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ADVANCE_or_VUT_TECHFLAG, CPPTEST_DS("__ds_step_autogen_20a8ed50_1752d056395"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_GOVERNMENT, CPPTEST_DS("__ds_step_autogen_dc01960c_1752d2aa889"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MAXTILEUNITS, CPPTEST_DS("__ds_step_autogen_66b549f8_17547b75c90"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_TERRAIN_et_al, CPPTEST_DS("__ds_step_autogen_c31a0616_17547b4e955"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTION_or_VUT_OTYPE, CPPTEST_DS("__ds_step_autogen_25fb7311_1752d91de16"));
CPPTEST_TEST_DS(metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_SERVERSETTING, CPPTEST_DS("__ds_step_autogen_78dbcb92_175479646ae"));
CPPTEST_TEST_DS(metaknowledge_tests_can_plr_see_all_sym_diplrels_of_test, CPPTEST_DS("__ds_step_autogen_7fdd270_17541c5a6b6"));
CPPTEST_TEST_DS(metaknowledge_tests_is_tile_seen_cadj_test, CPPTEST_DS("__ds_step_autogen_4c44f8e5_17542535a74"));
CPPTEST_TEST_DS(metaknowledge_tests_is_tile_seen_adj_test, CPPTEST_DS("__ds_step_autogen_ca8d73d2_17547333ec4"));
CPPTEST_TEST_DS(metaknowledge_tests_is_tile_seen_city_test, CPPTEST_DS("__ds_step_autogen_f34ac53e_17546e52432"));
CPPTEST_TEST_DS(metaknowledge_tests_is_tile_seen_traderoute_test, CPPTEST_DS("__ds_step_autogen_4339e984_17547cc5c85"));
CPPTEST_TEST_SUITE_END();
        

void metaknowledge_tests_mke_eval_req_test(void);
void CppTest_StubCallback_metaknowledge_tests_mke_eval_req_test_1_can_player_see_unit(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct unit * punit); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_mke_eval_req_test(void); */
void CppTest_StubCallback_metaknowledge_tests_mke_eval_req_test_2_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_mke_eval_req_test(void); */

/* CPPTEST_TEST_SUITE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testsuite>
    <metadata/>
    <steps>
        <step id="MultiVariableStep" uid="n/a" version="1">
            <step id="VariableStep" version="1">
                <name>diplstate_mock</name>
                <type>struct player_diplstate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>pcity_mock</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>city_array[]</name>
                <type>struct city *</type>
                <value>{NULL,&amp;pcity_mock}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>pow_player_mock</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>player_array[]</name>
                <type>struct player *</type>
                <value>{NULL,&amp;pow_player_mock}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>target_tile_mock</name>
                <type>struct tile *</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>target_tiles[]</name>
                <type>struct tile *</type>
                <value>{NULL,&amp;target_tile_mock}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>proute_iter_mock</name>
                <type>struct genlist_link *</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>proute_iters[]</name>
                <type>struct genlist_link *</type>
                <value>{NULL,&amp;proute_iter_mock}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>proute_mock</name>
                <type>struct trade_route *</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>proutes_mock[]</name>
                <type>struct trade_route *</type>
                <value>{NULL,&amp;proute_mock}</value>
            </step>
        </step>
    </steps>
</testsuite>

#endif
struct player_diplstate diplstate_mock;
struct city pcity_mock;
struct city * city_array[] = {NULL,&pcity_mock};
struct player pow_player_mock;
struct player * player_array[] = {NULL,&pow_player_mock};
struct tile * target_tile_mock;
struct tile * target_tiles[] = {NULL,&target_tile_mock};
struct genlist_link * proute_iter_mock;
struct genlist_link * proute_iters[] = {NULL,&proute_iter_mock};
struct trade_route * proute_mock;
struct trade_route * proutes_mock[] = {NULL,&proute_mock};
/* CPPTEST_TEST_SUITE_DATA_END */

void metaknowledge_tests_mke_eval_reqs_test(void);
void CppTest_StubCallback_metaknowledge_tests_mke_eval_reqs_test_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_mke_eval_reqs_test(void); */
void metaknowledge_tests_can_see_techs_of_target_test(void);
void CppTest_StubCallback_metaknowledge_tests_can_see_techs_of_target_test_1_player_has_embassy(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct player * pplayer2); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_can_see_techs_of_target_test(void); */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UNITSTATE(void);
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UNITSTATE_1_can_player_see_unit(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct unit * punit); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UNITSTATE(void); */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UNITSTATE_2_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UNITSTATE(void); */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINMOVES(void);
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINMOVES_1_can_player_see_unit(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct unit * punit); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINMOVES(void); */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINMOVES_2_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINMOVES(void); */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTIVITY(void);
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTIVITY_1_can_player_see_unit(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct unit * punit); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTIVITY(void); */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTIVITY_2_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTIVITY(void); */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UTFLAG_et_al(void);
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UTFLAG_et_al_1_can_player_see_unit(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct unit * punit); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UTFLAG_et_al(void); */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UTFLAG_et_al_2_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UTFLAG_et_al(void); */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL(void);
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL(void); */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL_2_player_diplstate_get(CppTest_StubCallInfo* stubCallInfo, struct player_diplstate ** __return, const struct player * plr1, const struct player * plr2); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL(void); */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL_3_player_has_embassy(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct player * pplayer2); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL(void); */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINSIZE(void);
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINSIZE_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINSIZE(void); */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINSIZE_2_player_can_see_city_externals(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pow_player, const struct city * target_city); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINSIZE(void); */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE(void);
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE(void); */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_2_tile_is_seen(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct tile * target_tile, const struct player * pow_player); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE(void); */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_3_tile_city(CppTest_StubCallInfo* stubCallInfo, struct city ** __return, const struct tile * ptile); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE(void); */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_4_city_owner(CppTest_StubCallInfo* stubCallInfo, struct player ** __return, const struct city * pcity); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE(void); */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_5_map_pos_to_tile(CppTest_StubCallInfo* stubCallInfo, struct tile ** __return, const struct civ_map * nmap, int x, int y); /* CPPTEST_TEST_CASE_CALLBACK void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE(void); */
CPPTEST_TEST_SUITE_REGISTRATION(metaknowledge_tests);

void metaknowledge_tests_testSuiteSetUp(void);
void metaknowledge_tests_testSuiteSetUp(void)
{
/* CPPTEST_TEST_SUITE_CODE_BEGIN TestSuiteSetUp */
/* CPPTEST_TEST_SUITE_CODE_END TestSuiteSetUp */
}

void metaknowledge_tests_testSuiteTearDown(void);
void metaknowledge_tests_testSuiteTearDown(void)
{
/* CPPTEST_TEST_SUITE_CODE_BEGIN TestSuiteTearDown */
/* CPPTEST_TEST_SUITE_CODE_END TestSuiteTearDown */
}

void metaknowledge_tests_setUp(void);
void metaknowledge_tests_setUp(void)
{
/* CPPTEST_TEST_SUITE_CODE_BEGIN TestCaseSetUp */
/* CPPTEST_TEST_SUITE_CODE_END TestCaseSetUp */
}

void metaknowledge_tests_tearDown(void);
void metaknowledge_tests_tearDown(void)
{
/* CPPTEST_TEST_SUITE_CODE_BEGIN TestCaseTearDown */
/* CPPTEST_TEST_SUITE_CODE_END TestCaseTearDown */
}


/* CPPTEST_TEST_CASE_BEGIN mke_eval_req_test */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_mke_eval_req_test_1_can_player_see_unit(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct unit * punit)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = CPPTEST_DS_GET_BOOL("can_player_see_unit_stub_return_value");
}
void CppTest_StubCallback_metaknowledge_tests_mke_eval_req_test_2_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:3.0 */
   *__return = CPPTEST_DS_GET_BOOL("is_req_active_stub_return_value");
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
void metaknowledge_tests_mke_eval_req_test()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>can_player_see_unit_stub_return_value</val>
                <val>is_req_active_stub_return_value</val>
                <val>targets_array_index_value</val>
                <val>assert_return_value</val>
            </row>
            <row>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>true</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>true</val>
                <val>false</val>
                <val>0</val>
                <val>TRI_NO</val>
            </row>
            <row>
                <val>true</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp; _target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp; _target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>targets[]</name>
                <type>struct unit *</type>
                <value>{&amp;_target_unit_6, NULL}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>targets[CPPTEST_DS_GET_UINTEGER("targets_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_UTFLAG</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>REQ_RANGE_LOCAL</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>RPT_CERTAIN</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("can_player_see_unit_stub_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>can_player_see_unit</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("is_req_active_stub_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="4" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="5" version="1">
            <step id="AssertionStep" uid="5.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"assert_return_value")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
const struct player * _target_player = & _target_player_1;
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * _target_city = & _target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
struct unit * targets[] = {&_target_unit_6, NULL};
const struct unit * _target_unit = targets[CPPTEST_DS_GET_UINTEGER("targets_array_index_value")];
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_UTFLAG;
_req_8.range = REQ_RANGE_LOCAL;
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = RPT_CERTAIN;
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("can_player_see_unit", &CppTest_StubCallback_metaknowledge_tests_mke_eval_req_test_1_can_player_see_unit);
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_mke_eval_req_test_2_is_req_active);
/* CPPTEST_TC_STEP_UID:4 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:5.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"assert_return_value"), _return);
}
/* CPPTEST_TEST_CASE_END mke_eval_req_test */

/* CPPTEST_TEST_CASE_BEGIN mke_eval_reqs_test */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_mke_eval_reqs_test_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = CPPTEST_DS_GET_BOOL("is_req_active_return_test");
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
/* CPPTEST_TEST_CASE_CONTEXT enum fc_tristate mke_eval_reqs(const struct player *, const struct player *, const struct player *, const struct city *, const struct impr_type *, const struct tile *, const struct unit *, const struct output_type *, const struct specialist *, const struct requirement_vector *, const enum req_problem_type) */
void metaknowledge_tests_mke_eval_reqs_test()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>V#E(enum req_problem_type)#_prob_type</val>
                <val>_return_test</val>
                <val>_reqs_8.size</val>
                <val>_req_8.source.kind</val>
                <val>is_req_active_return_test</val>
            </row>
            <row>
                <val>RPT_POSSIBLE</val>
                <val>TRI_YES</val>
                <val>0</val>
                <val>VUT_UTFLAG</val>
                <val>true</val>
            </row>
            <row>
                <val>RPT_CERTAIN</val>
                <val>TRI_YES</val>
                <val>1</val>
                <val>VUT_UTFLAG</val>
                <val>true</val>
            </row>
            <row>
                <val>RPT_POSSIBLE</val>
                <val>TRI_MAYBE</val>
                <val>1</val>
                <val>VUT_UTFLAG</val>
                <val>true</val>
            </row>
            <row>
                <val>RPT_CERTAIN</val>
                <val>TRI_NO</val>
                <val>1</val>
                <val>VUT_UTFLAG</val>
                <val>false</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp; _target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp; _target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>NULL</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_reqs_8</name>
                <type>struct requirement_vector</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_reqs_8.size</name>
                <type/>
                <value>CPPTEST_DS_GET_INTEGER("_reqs_8.size")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_reqs_8.p</name>
                <type/>
                <value>&amp;_req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_reqs</name>
                <type>const struct requirement_vector *</type>
                <value>&amp; _reqs_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"V#E(enum req_problem_type)#_prob_type")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"test val: %s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("is_req_active_return_test")</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="3" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_reqs</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _reqs, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="4" version="1">
            <step id="AssertionStep" uid="4.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
            <step id="AssertionStep" uid="4.1" version="1">
                <type>CPPTEST_ASSERT_PTR_EQUAL</type>
                <P1>0</P1>
                <P2>wld.cities</P2>
                <P3/>
                <P4/>
            </step>
            <step id="AssertionStep" uid="4.2" version="1">
                <type>CPPTEST_ASSERT_PTR_EQUAL</type>
                <P1>0</P1>
                <P2>wld.units</P2>
                <P3/>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
const struct player * _target_player = & _target_player_1;
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * _target_city = & _target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
const struct unit * _target_unit = NULL;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement_vector _reqs_8;
_reqs_8.size = CPPTEST_DS_GET_INTEGER("_reqs_8.size");
struct requirement _req_8;
_req_8.source.kind = CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind");
_reqs_8.p = &_req_8;
const struct requirement_vector * _reqs = & _reqs_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"V#E(enum req_problem_type)#_prob_type");
enum fc_tristate _return;
nologmsg = "test val: %s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_mke_eval_reqs_test_1_is_req_active);
/* CPPTEST_TC_STEP_UID:3 */
_return = mke_eval_reqs(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _reqs, _prob_type);
/* CPPTEST_TC_STEP_UID:4.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test"), _return);
/* CPPTEST_TC_STEP_UID:4.1 */
CPPTEST_ASSERT_PTR_EQUAL(0, wld.cities);
/* CPPTEST_TC_STEP_UID:4.2 */
CPPTEST_ASSERT_PTR_EQUAL(0, wld.units);
}
/* CPPTEST_TEST_CASE_END mke_eval_reqs_test */

/* CPPTEST_TEST_CASE_BEGIN can_see_techs_of_target_test */
/* CPPTEST_TEST_CASE_DESCRIPTION 
function flow graph:
_pow_player_1_test == _target_player_1_test || player_has_embassy()
 */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_can_see_techs_of_target_test_1_player_has_embassy(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct player * pplayer2)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = CPPTEST_DS_GET_BOOL("player_has_embassy_stub_return_value");
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
/* CPPTEST_TEST_CASE_CONTEXT _Bool can_see_techs_of_target(const struct player *, const struct player *) */
void metaknowledge_tests_can_see_techs_of_target_test()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>pow_player_1_players_index_value</val>
                <val>target_player_1_players_index_value</val>
                <val>player_has_embassy_stub_return_value</val>
                <val>assert_return_value</val>
            </row>
            <row>
                <val>0</val>
                <val>0</val>
                <val>false</val>
                <val>true</val>
            </row>
            <row>
                <val>0</val>
                <val>1</val>
                <val>false</val>
                <val>false</val>
            </row>
            <row>
                <val>0</val>
                <val>1</val>
                <val>true</val>
                <val>true</val>
            </row>
            <row>
                <val>0</val>
                <val>1</val>
                <val>false</val>
                <val>false</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>players[]</name>
                <type>struct player *</type>
                <value>{&amp;_pow_player_1, &amp;_target_player_2}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>players[CPPTEST_DS_GET_UINTEGER("pow_player_1_players_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>players[CPPTEST_DS_GET_UINTEGER("target_player_1_players_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>_Bool</type>
                <value/>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("player_has_embassy_stub_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>player_has_embassy</function>
            <code><![CDATA[printf("*** param num: %d\n", stubCallInfo->callNo);]]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="3" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>can_see_techs_of_target</name>
            <params>_pow_player, _target_player</params>
        </step>
        <step id="AssertionsStep" uid="4" version="1">
            <step id="AssertionStep" uid="4.0" version="1">
                <type>CPPTEST_ASSERT_BOOL_EQUAL_MESSAGE</type>
                <P1>"function return"</P1>
                <P2>CPPTEST_DS_GET_BOOL("assert_return_value")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
        <step id="ReportsStep" uid="5" version="1">
            <step id="ReportStep" uid="5.0" version="1">
                <type>CPPTEST_REPORT</type>
                <P1>"A thing"</P1>
                <P2/>
                <P3/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_1;
struct player _target_player_2;
struct player * players[] = {&_pow_player_1, &_target_player_2};
const struct player * _pow_player = players[CPPTEST_DS_GET_UINTEGER("pow_player_1_players_index_value")];
const struct player * _target_player = players[CPPTEST_DS_GET_UINTEGER("target_player_1_players_index_value")];
_Bool _return;
CPPTEST_REGISTER_STUB_CALLBACK("player_has_embassy", &CppTest_StubCallback_metaknowledge_tests_can_see_techs_of_target_test_1_player_has_embassy);
/* CPPTEST_TC_STEP_UID:3 */
_return = can_see_techs_of_target(_pow_player, _target_player);
/* CPPTEST_TC_STEP_UID:4.0 */
CPPTEST_ASSERT_BOOL_EQUAL_MESSAGE("function return", CPPTEST_DS_GET_BOOL("assert_return_value"), _return);
/* CPPTEST_TC_STEP_UID:5.0 */
CPPTEST_REPORT("A thing");
}
/* CPPTEST_TEST_CASE_END can_see_techs_of_target_test */


/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_UNITSTATE */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UNITSTATE_1_can_player_see_unit(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct unit * punit)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = CPPTEST_DS_GET_BOOL("_can_player_see_unit_stub_return_value");
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UNITSTATE_2_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:3.0 */
   *__return = true;
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UNITSTATE()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.source.kind</val>
                <val>_req_8.range</val>
                <val>_req_8.source.value.unit_state</val>
                <val>targets_array_index_value</val>
                <val>_req_prob_type_value</val>
                <val>_can_player_see_unit_stub_return_value</val>
                <val>players_array_index_value</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>VUT_UNITSTATE</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>USP_TRANSPORTED</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_UNITSTATE</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>USP_TRANSPORTED</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_UNITSTATE</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>USP_TRANSPORTED</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_UNITSTATE</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>USP_TRANSPORTED</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_UNITSTATE</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>USP_LIVABLE_TILE</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_UNITSTATE</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>USP_DOMESTIC_TILE</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_UNITSTATE</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>USP_TRANSPORTING</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_UNITSTATE</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>USP_NATIVE_TILE</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_UNITSTATE</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>USP_NATIVE_EXTRA</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_UNITSTATE</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>USP_HAS_HOME_CITY</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_UNITSTATE</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>USP_HAS_HOME_CITY</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_UNITSTATE</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>USP_MOVED_THIS_TURN</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_UNITSTATE</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>USP_COUNT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp; _target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp; _target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>players[]</name>
                <type>struct player *</type>
                <value>{NULL, _pow_player}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>players[CPPTEST_DS_GET_UINTEGER("players_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>targets[]</name>
                <type>struct unit *</type>
                <value>{NULL, &amp;_target_unit_6}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>targets[CPPTEST_DS_GET_UINTEGER("targets_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.value.unit_state</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum ustate_prop,"_req_8.source.value.unit_state")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("_can_player_see_unit_stub_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>can_player_see_unit</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="4" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="5" version="1">
            <step id="AssertionStep" uid="5.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
const struct player * _target_player = & _target_player_1;
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * _target_city = & _target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
struct player * players[] = {NULL, _pow_player};
_target_unit_6.owner = players[CPPTEST_DS_GET_UINTEGER("players_array_index_value")];
struct unit * targets[] = {NULL, &_target_unit_6};
const struct unit * _target_unit = targets[CPPTEST_DS_GET_UINTEGER("targets_array_index_value")];
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind");
_req_8.range = CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range");
_req_8.source.value.unit_state = CPPTEST_DS_GET_ENUM(enum ustate_prop,"_req_8.source.value.unit_state");
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value");
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("can_player_see_unit", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UNITSTATE_1_can_player_see_unit);
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UNITSTATE_2_is_req_active);
/* CPPTEST_TC_STEP_UID:4 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:5.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_UNITSTATE */

/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_MINMOVES */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINMOVES_1_can_player_see_unit(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct unit * punit)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = CPPTEST_DS_GET_BOOL("_can_player_see_unit_stub_return_value");
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINMOVES_2_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:3.0 */
   *__return = true;
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINMOVES()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.range</val>
                <val>targets_array_index_value</val>
                <val>_req_prob_type_value</val>
                <val>_can_player_see_unit_stub_return_value</val>
                <val>players_array_index_value</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CITY</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_TRADEROUTE</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CONTINENT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_TEAM</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ALLIANCE</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_WORLD</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_COUNT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp; _target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp; _target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>players[]</name>
                <type>struct player *</type>
                <value>{NULL, _pow_player}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>players[CPPTEST_DS_GET_UINTEGER("players_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>targets[]</name>
                <type>struct unit *</type>
                <value>{NULL, &amp;_target_unit_6}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>targets[CPPTEST_DS_GET_UINTEGER("targets_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_MINMOVES</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("_can_player_see_unit_stub_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>can_player_see_unit</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="4" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="5" version="1">
            <step id="AssertionStep" uid="5.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
const struct player * _target_player = & _target_player_1;
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * _target_city = & _target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
struct player * players[] = {NULL, _pow_player};
_target_unit_6.owner = players[CPPTEST_DS_GET_UINTEGER("players_array_index_value")];
struct unit * targets[] = {NULL, &_target_unit_6};
const struct unit * _target_unit = targets[CPPTEST_DS_GET_UINTEGER("targets_array_index_value")];
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_MINMOVES;
_req_8.range = CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range");
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value");
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("can_player_see_unit", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINMOVES_1_can_player_see_unit);
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINMOVES_2_is_req_active);
/* CPPTEST_TC_STEP_UID:4 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:5.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_MINMOVES */

/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_ACTIVITY */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTIVITY_1_can_player_see_unit(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct unit * punit)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = CPPTEST_DS_GET_BOOL("_can_player_see_unit_stub_return_value");
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTIVITY_2_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:3.0 */
   *__return = true;
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTIVITY()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.range</val>
                <val>targets_array_index_value</val>
                <val>_req_prob_type_value</val>
                <val>_can_player_see_unit_stub_return_value</val>
                <val>players_array_index_value</val>
                <val>_req_8.source.value.activity</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>REQ_RANGE_COUNT</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>0</val>
                <val>ACTIVITY_IDLE</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_COUNT</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>ACTIVITY_IDLE</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_COUNT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>1</val>
                <val>ACTIVITY_IDLE</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_COUNT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>ACTIVITY_IDLE</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_COUNT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>ACTIVITY_IDLE</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_COUNT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>ACTIVITY_EXPLORE</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_COUNT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>ACTIVITY_GOTO</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp; _target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp; _target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>players[]</name>
                <type>struct player *</type>
                <value>{NULL, _pow_player}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>players[CPPTEST_DS_GET_UINTEGER("players_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>targets[]</name>
                <type>struct unit *</type>
                <value>{NULL, &amp;_target_unit_6}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>targets[CPPTEST_DS_GET_UINTEGER("targets_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_ACTIVITY</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.value.activity</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum unit_activity,"_req_8.source.value.activity")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("_can_player_see_unit_stub_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>can_player_see_unit</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="4" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="5" version="1">
            <step id="AssertionStep" uid="5.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
const struct player * _target_player = & _target_player_1;
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * _target_city = & _target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
struct player * players[] = {NULL, _pow_player};
_target_unit_6.owner = players[CPPTEST_DS_GET_UINTEGER("players_array_index_value")];
struct unit * targets[] = {NULL, &_target_unit_6};
const struct unit * _target_unit = targets[CPPTEST_DS_GET_UINTEGER("targets_array_index_value")];
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_ACTIVITY;
_req_8.range = CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range");
_req_8.source.value.activity = CPPTEST_DS_GET_ENUM(enum unit_activity,"_req_8.source.value.activity");
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value");
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("can_player_see_unit", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTIVITY_1_can_player_see_unit);
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTIVITY_2_is_req_active);
/* CPPTEST_TC_STEP_UID:4 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:5.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_ACTIVITY */

/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_UTFLAG_et_al */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UTFLAG_et_al_1_can_player_see_unit(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct unit * punit)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = CPPTEST_DS_GET_BOOL("_can_player_see_unit_stub_return_value");
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UTFLAG_et_al_2_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:3.0 */
   *__return = true;
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UTFLAG_et_al()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.source.kind</val>
                <val>_req_8.range</val>
                <val>targets_array_index_value</val>
                <val>_req_prob_type_value</val>
                <val>_can_player_see_unit_stub_return_value</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>VUT_UTFLAG</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_UTFLAG</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_UTFLAG</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_UTFLAG</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_UTFLAG</val>
                <val>REQ_RANGE_CADJACENT</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_UTYPE</val>
                <val>REQ_RANGE_ADJACENT</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_UCLASS</val>
                <val>REQ_RANGE_CONTINENT</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_UCFLAG</val>
                <val>REQ_RANGE_CITY</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_MINVETERAN</val>
                <val>REQ_RANGE_TRADEROUTE</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_MINHP</val>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_MINHP</val>
                <val>REQ_RANGE_TEAM</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_MINHP</val>
                <val>REQ_RANGE_ALLIANCE</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_MINHP</val>
                <val>REQ_RANGE_WORLD</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_MINHP</val>
                <val>REQ_RANGE_COUNT</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_MINHP</val>
                <val>REQ_RANGE_CADJACENT</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp; _target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp; _target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>targets[]</name>
                <type>struct unit *</type>
                <value>{NULL, &amp;_target_unit_6}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>targets[CPPTEST_DS_GET_UINTEGER("targets_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("_can_player_see_unit_stub_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>can_player_see_unit</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="4" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="5" version="1">
            <step id="AssertionStep" uid="5.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
const struct player * _target_player = & _target_player_1;
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * _target_city = & _target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
_target_unit_6.owner = &_target_unit_6;
struct unit * targets[] = {NULL, &_target_unit_6};
const struct unit * _target_unit = targets[CPPTEST_DS_GET_UINTEGER("targets_array_index_value")];
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind");
_req_8.range = CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range");
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value");
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("can_player_see_unit", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UTFLAG_et_al_1_can_player_see_unit);
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_UTFLAG_et_al_2_is_req_active);
/* CPPTEST_TC_STEP_UID:4 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:5.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_UTFLAG_et_al */

/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_DIPLREL */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL_2_player_diplstate_get(CppTest_StubCallInfo* stubCallInfo, struct player_diplstate ** __return, const struct player * plr1, const struct player * plr2)
{
   /* CPPTEST_TC_STEP_UID:3.0 */
   *__return = &diplstate_mock;
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL_3_player_has_embassy(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct player * pplayer2)
{
   if (stubCallInfo->callNo == 1){
      /* CPPTEST_TC_STEP_UID:4.0 */
      *__return = CPPTEST_DS_GET_BOOL("_player_has_embassy_stub_return_value_1");
   } else if (stubCallInfo->callNo == 2){
      /* CPPTEST_TC_STEP_UID:4.0 */
      *__return = CPPTEST_DS_GET_BOOL("_player_has_embassy_stub_return_value_2");
   }
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.range</val>
                <val>other_players_array_index_value</val>
                <val>target_players_array_index_value</val>
                <val>pow_players_array_index_value</val>
                <val>_req_prob_type_value</val>
                <val>_player_has_embassy_stub_return_value_1</val>
                <val>_player_has_embassy_stub_return_value_2</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>1</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>2</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>2</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>true</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>2</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_TEAM</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ALLIANCE</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_WORLD</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CITY</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_TRADEROUTE</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CONTINENT</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_COUNT</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>target_players[]</name>
                <type>struct player *</type>
                <value>{NULL,&amp; _target_player_1,&amp; _pow_player_0}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>target_players[CPPTEST_DS_GET_UINTEGER("target_players_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>other_players[]</name>
                <type>struct player *</type>
                <value>{NULL, &amp;_other_player_2,&amp; _pow_player_0}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>other_players[CPPTEST_DS_GET_UINTEGER("other_players_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp; _target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>players[]</name>
                <type>struct player *</type>
                <value>{NULL, _pow_player}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>players[CPPTEST_DS_GET_UINTEGER("pow_players_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_DIPLREL</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.value.activity</name>
                <type/>
                <value>ACTIVITY_IDLE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>diplstate_mock.contact_turns_left</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>&amp;diplstate_mock</P2>
                <P3/>
                <P4/>
            </step>
            <function>player_diplstate_get</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="4" version="1">
            <step id="StubConfigurationEntryStep" uid="4.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>{CPPTEST_DS_GET_BOOL("_player_has_embassy_stub_return_value_1"),CPPTEST_DS_GET_BOOL("_player_has_embassy_stub_return_value_2")}</P2>
                <P3/>
                <P4/>
            </step>
            <function>player_has_embassy</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="5" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="6" version="1">
            <step id="AssertionStep" uid="6.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
struct player * target_players[] = {NULL,& _target_player_1,& _pow_player_0};
const struct player * _target_player = target_players[CPPTEST_DS_GET_UINTEGER("target_players_array_index_value")];
struct player _other_player_2;
struct player * other_players[] = {NULL, &_other_player_2,& _pow_player_0};
const struct player * _other_player = other_players[CPPTEST_DS_GET_UINTEGER("other_players_array_index_value")];
struct city _target_city_3;
const struct city * _target_city = & _target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
struct player * players[] = {NULL, _pow_player};
_target_unit_6.owner = players[CPPTEST_DS_GET_UINTEGER("pow_players_array_index_value")];
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_DIPLREL;
_req_8.range = CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range");
_req_8.source.value.activity = ACTIVITY_IDLE;
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value");
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
diplstate_mock.contact_turns_left = 0;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL_1_is_req_active);
CPPTEST_REGISTER_STUB_CALLBACK("player_diplstate_get", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL_2_player_diplstate_get);
CPPTEST_REGISTER_STUB_CALLBACK("player_has_embassy", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_DIPLREL_3_player_has_embassy);
/* CPPTEST_TC_STEP_UID:5 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:6.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_DIPLREL */

/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_MINSIZE */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINSIZE_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINSIZE_2_player_can_see_city_externals(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pow_player, const struct city * target_city)
{
   /* CPPTEST_TC_STEP_UID:3.0 */
   *__return = CPPTEST_DS_GET_BOOL("player_can_see_city_externals_return_value");
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINSIZE()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>target_city_array_index_value</val>
                <val>pow_players_array_index_value</val>
                <val>_req_prob_type_value</val>
                <val>player_can_see_city_externals_return_value</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>0</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>1</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>1</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp;_target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp;_other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>target_city[]</name>
                <type>struct city *</type>
                <value>{NULL,&amp;_target_city_3}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>target_city[CPPTEST_DS_GET_UINTEGER("target_city_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>players[]</name>
                <type>struct player *</type>
                <value>{NULL, _pow_player}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>players[CPPTEST_DS_GET_UINTEGER("pow_players_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_MINSIZE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.value.activity</name>
                <type/>
                <value>ACTIVITY_IDLE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("player_can_see_city_externals_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>player_can_see_city_externals</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="4" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="5" version="1">
            <step id="AssertionStep" uid="5.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
const struct player * _target_player = &_target_player_1;
struct player _other_player_2;
const struct player * _other_player = &_other_player_2;
struct city _target_city_3;
struct city * target_city[] = {NULL,&_target_city_3};
const struct city * _target_city = target_city[CPPTEST_DS_GET_UINTEGER("target_city_array_index_value")];
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
struct player * players[] = {NULL, _pow_player};
_target_unit_6.owner = players[CPPTEST_DS_GET_UINTEGER("pow_players_array_index_value")];
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_MINSIZE;
_req_8.source.value.activity = ACTIVITY_IDLE;
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value");
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINSIZE_1_is_req_active);
CPPTEST_REGISTER_STUB_CALLBACK("player_can_see_city_externals", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MINSIZE_2_player_can_see_city_externals);
/* CPPTEST_TC_STEP_UID:4 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:5.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_MINSIZE */

/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_CITYTILE */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_2_tile_is_seen(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct tile * target_tile, const struct player * pow_player)
{
   /* CPPTEST_TC_STEP_UID:3.0 */
   *__return = CPPTEST_DS_GET_BOOL("tile_is_seen_return_value");
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_3_tile_city(CppTest_StubCallInfo* stubCallInfo, struct city ** __return, const struct tile * ptile)
{
   /* CPPTEST_TC_STEP_UID:4.0 */
   *__return = city_array[CPPTEST_DS_GET_INTEGER("tile_city_stub_return_array_index")];
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_4_city_owner(CppTest_StubCallInfo* stubCallInfo, struct player ** __return, const struct city * pcity)
{
   /* CPPTEST_TC_STEP_UID:5.0 */
   *__return = player_array[CPPTEST_DS_GET_INTEGER("city_owner_stub_return_array_index")];
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_5_map_pos_to_tile(CppTest_StubCallInfo* stubCallInfo, struct tile ** __return, const struct civ_map * nmap, int x, int y)
{
   /* CPPTEST_TC_STEP_UID:6.0 */
   *__return = target_tiles[CPPTEST_DS_GET_INTEGER("map_pos_to_tile_return_value")];
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.range</val>
                <val>target_tile_array_index_value</val>
                <val>tile_city_stub_return_array_index</val>
                <val>city_owner_stub_return_array_index</val>
                <val>_req_prob_type_value</val>
                <val>tile_is_seen_return_value</val>
                <val>wld.map.topology_id</val>
                <val>wld.map.num_valid_dirs</val>
                <val>map_pos_to_tile_return_value</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>REQ_RANGE_COUNT</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_COUNT</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>1</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>0</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0xFF</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>1</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>1</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>1</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>0</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>1</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>1</val>
                <val>1</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0xFF</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>1</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>1</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>1</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>0</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>1</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>1</val>
                <val>1</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_CITY</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_TRADEROUTE</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CONTINENT</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_TEAM</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ALLIANCE</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_WORLD</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_COUNT</val>
                <val>1</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; pow_player_mock</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp;_target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp;_other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp;_target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5.index</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>target_tile[]</name>
                <type>struct tile *</type>
                <value>{NULL,&amp;_target_tile_5}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>target_tile[CPPTEST_DS_GET_UINTEGER("target_tile_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>_pow_player</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_CITYTILE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.value.activity</name>
                <type/>
                <value>ACTIVITY_IDLE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.topology_id</name>
                <type/>
                <value>CPPTEST_DS_GET_INTEGER("wld.map.topology_id")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.num_valid_dirs</name>
                <type/>
                <value>CPPTEST_DS_GET_INTEGER("wld.map.num_valid_dirs")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.num_cardinal_dirs</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.cardinal_dirs[0]</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.cardinal_dirs[1]</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.xsize</name>
                <type/>
                <value>1</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("tile_is_seen_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>tile_is_seen</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="4" version="1">
            <step id="StubConfigurationEntryStep" uid="4.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>city_array[CPPTEST_DS_GET_INTEGER("tile_city_stub_return_array_index")]</P2>
                <P3/>
                <P4/>
            </step>
            <function>tile_city</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="5" version="1">
            <step id="StubConfigurationEntryStep" uid="5.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>player_array[CPPTEST_DS_GET_INTEGER("city_owner_stub_return_array_index")]</P2>
                <P3/>
                <P4/>
            </step>
            <function>city_owner</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="6" version="1">
            <step id="StubConfigurationEntryStep" uid="6.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>target_tiles[CPPTEST_DS_GET_INTEGER("map_pos_to_tile_return_value")]</P2>
                <P3/>
                <P4/>
            </step>
            <function>map_pos_to_tile</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="7" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="8" version="1">
            <step id="AssertionStep" uid="8.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & pow_player_mock;
struct player _target_player_1;
const struct player * _target_player = &_target_player_1;
struct player _other_player_2;
const struct player * _other_player = &_other_player_2;
struct city _target_city_3;
const struct city * _target_city = &_target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
_target_tile_5.index = 1;
struct tile * target_tile[] = {NULL,&_target_tile_5};
const struct tile * _target_tile = target_tile[CPPTEST_DS_GET_UINTEGER("target_tile_array_index_value")];
struct unit _target_unit_6;
_target_unit_6.owner = _pow_player;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_CITYTILE;
_req_8.range = CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range");
_req_8.source.value.activity = ACTIVITY_IDLE;
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value");
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
wld.map.topology_id = CPPTEST_DS_GET_INTEGER("wld.map.topology_id");
wld.map.num_valid_dirs = CPPTEST_DS_GET_INTEGER("wld.map.num_valid_dirs");
wld.map.num_cardinal_dirs = 1;
wld.map.cardinal_dirs[0] = 0;
wld.map.cardinal_dirs[1] = 0;
wld.map.xsize = 1;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_1_is_req_active);
CPPTEST_REGISTER_STUB_CALLBACK("tile_is_seen", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_2_tile_is_seen);
CPPTEST_REGISTER_STUB_CALLBACK("tile_city", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_3_tile_city);
CPPTEST_REGISTER_STUB_CALLBACK("city_owner", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_4_city_owner);
CPPTEST_REGISTER_STUB_CALLBACK("map_pos_to_tile", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_CITYTILE_5_map_pos_to_tile);
/* CPPTEST_TC_STEP_UID:7 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:8.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_CITYTILE */

/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_IMPR_GENUS */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPR_GENUS_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPR_GENUS_2_can_player_see_city_internals(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct city * pcity)
{
   /* CPPTEST_TC_STEP_UID:3.0 */
   *__return = CPPTEST_DS_GET_BOOL("can_player_see_city_internals_return_value");
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPR_GENUS()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.range</val>
                <val>target_citys_index_value</val>
                <val>_req_prob_type_value</val>
                <val>can_player_see_city_internals_return_value</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp; _target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>target_citys[]</name>
                <type>const struct city *</type>
                <value>{NULL,&amp; _target_city_3}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>target_citys[CPPTEST_DS_GET_UINTEGER("target_citys_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>_pow_player</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_IMPR_GENUS</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("can_player_see_city_internals_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>can_player_see_city_internals</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="4" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="5" version="1">
            <step id="AssertionStep" uid="5.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
const struct player * _target_player = & _target_player_1;
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * target_citys[] = {NULL,& _target_city_3};
const struct city * _target_city = target_citys[CPPTEST_DS_GET_UINTEGER("target_citys_index_value")];
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
_target_unit_6.owner = _pow_player;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_IMPR_GENUS;
_req_8.range = CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range");
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value");
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPR_GENUS_1_is_req_active);
CPPTEST_REGISTER_STUB_CALLBACK("can_player_see_city_internals", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPR_GENUS_2_can_player_see_city_internals);
/* CPPTEST_TC_STEP_UID:4 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:5.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_IMPR_GENUS */

/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_IMPROVEMENT */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPROVEMENT_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPROVEMENT_2_can_player_see_city_internals(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct city * pcity)
{
   /* CPPTEST_TC_STEP_UID:3.0 */
   *__return = CPPTEST_DS_GET_BOOL("can_player_see_city_internals_return_value");
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPROVEMENT_3_is_improvement_visible(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct impr_type * pimprove)
{
   /* CPPTEST_TC_STEP_UID:4.0 */
   *__return = CPPTEST_DS_GET_BOOL("is_improvement_visible_return_vlaue");
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPROVEMENT_4_player_can_see_city_externals(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pow_player, const struct city * target_city)
{
   /* CPPTEST_TC_STEP_UID:5.0 */
   *__return = CPPTEST_DS_GET_BOOL("player_can_see_city_externals_return_value");
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPROVEMENT()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.range</val>
                <val>target_citys_index_value</val>
                <val>_req_prob_type_value</val>
                <val>can_player_see_city_internals_return_value</val>
                <val>is_improvement_visible_return_vlaue</val>
                <val>player_can_see_city_externals_return_value</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>REQ_RANGE_WORLD</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_ALLIANCE</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_TEAM</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_CONTINENT</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_TRADEROUTE</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CITY</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>true</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>true</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>true</val>
                <val>true</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_COUNT</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp; _target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>target_citys[]</name>
                <type>const struct city *</type>
                <value>{NULL,&amp; _target_city_3}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>target_citys[CPPTEST_DS_GET_UINTEGER("target_citys_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>_pow_player</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_IMPROVEMENT</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("can_player_see_city_internals_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>can_player_see_city_internals</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="4" version="1">
            <step id="StubConfigurationEntryStep" uid="4.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("is_improvement_visible_return_vlaue")</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_improvement_visible</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="5" version="1">
            <step id="StubConfigurationEntryStep" uid="5.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("player_can_see_city_externals_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>player_can_see_city_externals</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="6" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="7" version="1">
            <step id="AssertionStep" uid="7.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
const struct player * _target_player = & _target_player_1;
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * target_citys[] = {NULL,& _target_city_3};
const struct city * _target_city = target_citys[CPPTEST_DS_GET_UINTEGER("target_citys_index_value")];
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
_target_unit_6.owner = _pow_player;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_IMPROVEMENT;
_req_8.range = CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range");
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value");
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPROVEMENT_1_is_req_active);
CPPTEST_REGISTER_STUB_CALLBACK("can_player_see_city_internals", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPROVEMENT_2_can_player_see_city_internals);
CPPTEST_REGISTER_STUB_CALLBACK("is_improvement_visible", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPROVEMENT_3_is_improvement_visible);
CPPTEST_REGISTER_STUB_CALLBACK("player_can_see_city_externals", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_IMPROVEMENT_4_player_can_see_city_externals);
/* CPPTEST_TC_STEP_UID:6 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:7.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_IMPROVEMENT */

/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_NATION_or_VUT_NATIONGROUP */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_NATION_or_VUT_NATIONGROUP_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_NATION_or_VUT_NATIONGROUP()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.source.kind</val>
                <val>_req_8.range</val>
                <val>target_players_array_index_value</val>
                <val>_req_prob_type_value</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>VUT_NATION</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_NATIONGROUP</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_NATIONGROUP</val>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_NATIONGROUP</val>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_NATIONGROUP</val>
                <val>REQ_RANGE_TEAM</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_NATIONGROUP</val>
                <val>REQ_RANGE_ALLIANCE</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_NATIONGROUP</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>TRI_YES</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>target_players[]</name>
                <type>struct player *</type>
                <value>{NULL,&amp; _target_player_1}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>target_players[CPPTEST_DS_GET_UINTEGER("target_players_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp;_target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>_pow_player</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="3" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="4" version="1">
            <step id="AssertionStep" uid="4.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
struct player * target_players[] = {NULL,& _target_player_1};
const struct player * _target_player = target_players[CPPTEST_DS_GET_UINTEGER("target_players_array_index_value")];
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * _target_city = &_target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
_target_unit_6.owner = _pow_player;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind");
_req_8.range = CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range");
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value");
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_NATION_or_VUT_NATIONGROUP_1_is_req_active);
/* CPPTEST_TC_STEP_UID:3 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:4.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_NATION_or_VUT_NATIONGROUP */

/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_ADVANCE_or_VUT_TECHFLAG */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ADVANCE_or_VUT_TECHFLAG_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ADVANCE_or_VUT_TECHFLAG()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.source.kind</val>
                <val>_req_8.range</val>
                <val>pow_players_array_index_value</val>
                <val>target_players_array_index_value</val>
                <val>_req_prob_type_value</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>VUT_ADVANCE</val>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_TECHFLAG</val>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_TECHFLAG</val>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_TECHFLAG</val>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_TECHFLAG</val>
                <val>REQ_RANGE_PLAYER</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_TECHFLAG</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>pow_players[]</name>
                <type>struct player *</type>
                <value>{NULL,&amp; _pow_player_0}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>pow_players[CPPTEST_DS_GET_UINTEGER("pow_players_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>pow_players[CPPTEST_DS_GET_UINTEGER("target_players_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp;_target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>_pow_player</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="3" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="4" version="1">
            <step id="AssertionStep" uid="4.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
struct player * pow_players[] = {NULL,& _pow_player_0};
const struct player * _pow_player = pow_players[CPPTEST_DS_GET_UINTEGER("pow_players_array_index_value")];
struct player _target_player_1;
const struct player * _target_player = pow_players[CPPTEST_DS_GET_UINTEGER("target_players_array_index_value")];
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * _target_city = &_target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
_target_unit_6.owner = _pow_player;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind");
_req_8.range = CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range");
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value");
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ADVANCE_or_VUT_TECHFLAG_1_is_req_active);
/* CPPTEST_TC_STEP_UID:3 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:4.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_ADVANCE_or_VUT_TECHFLAG */

/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_GOVERNMENT */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_GOVERNMENT_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_GOVERNMENT_2_could_intel_with_player(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct player * aplayer)
{
   /* CPPTEST_TC_STEP_UID:3.0 */
   *__return = CPPTEST_DS_GET_BOOL("could_intel_with_player_return_value");
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_GOVERNMENT()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.range</val>
                <val>target_players_array_index_value</val>
                <val>pow_players_array_index_value</val>
                <val>_req_prob_type_value</val>
                <val>could_intel_with_player_return_value</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>1</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>1</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>TRI_YES</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>pow_players[]</name>
                <type>struct player *</type>
                <value>{NULL,&amp; _pow_player_0}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>pow_players[CPPTEST_DS_GET_UINTEGER("pow_players_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>pow_players[CPPTEST_DS_GET_UINTEGER("target_players_array_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp; _target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>_pow_player</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_GOVERNMENT</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("could_intel_with_player_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>could_intel_with_player</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="4" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="5" version="1">
            <step id="AssertionStep" uid="5.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
struct player * pow_players[] = {NULL,& _pow_player_0};
const struct player * _pow_player = pow_players[CPPTEST_DS_GET_UINTEGER("pow_players_array_index_value")];
struct player _target_player_1;
const struct player * _target_player = pow_players[CPPTEST_DS_GET_UINTEGER("target_players_array_index_value")];
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * _target_city = & _target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
_target_unit_6.owner = _pow_player;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_GOVERNMENT;
_req_8.range = CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range");
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value");
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_GOVERNMENT_1_is_req_active);
CPPTEST_REGISTER_STUB_CALLBACK("could_intel_with_player", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_GOVERNMENT_2_could_intel_with_player);
/* CPPTEST_TC_STEP_UID:4 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:5.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_GOVERNMENT */

/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_MAXTILEUNITS */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MAXTILEUNITS_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MAXTILEUNITS_2_can_player_see_hypotetic_units_at(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct tile * ptile)
{
   if (stubCallInfo->callNo == 1){
      /* CPPTEST_TC_STEP_UID:3.0 */
      *__return = CPPTEST_DS_GET_BOOL("can_player_see_hypotetic_units_at_return_value");
   } else if (stubCallInfo->callNo == 2){
      /* CPPTEST_TC_STEP_UID:3.0 */
      *__return = CPPTEST_DS_GET_BOOL("can_player_see_hypotetic_units_at_return_value2");
   }
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MAXTILEUNITS_3_map_pos_to_tile(CppTest_StubCallInfo* stubCallInfo, struct tile ** __return, const struct civ_map * nmap, int x, int y)
{
   /* CPPTEST_TC_STEP_UID:4.0 */
   *__return = target_tiles[CPPTEST_DS_GET_INTEGER("map_pos_to_tile_return_value")];
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MAXTILEUNITS()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.range</val>
                <val>target_tiles_index_value</val>
                <val>target_citys_index_value</val>
                <val>_req_prob_type_value</val>
                <val>can_player_see_hypotetic_units_at_return_value</val>
                <val>can_player_see_hypotetic_units_at_return_value2</val>
                <val>wld.map.topology_id</val>
                <val>wld.map.num_cardinal_dirs</val>
                <val>map_pos_to_tile_return_value</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>true</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>true</val>
                <val>4</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>true</val>
                <val>0</val>
                <val>1</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>true</val>
                <val>0</val>
                <val>1</val>
                <val>1</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>false</val>
                <val>0</val>
                <val>1</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>true</val>
                <val>4</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>true</val>
                <val>0</val>
                <val>1</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>true</val>
                <val>0</val>
                <val>1</val>
                <val>1</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>true</val>
                <val>false</val>
                <val>0</val>
                <val>1</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CONTINENT</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_CITY</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_TRADEROUTE</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_PLAYER</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_TEAM</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_ALLIANCE</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_WORLD</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>REQ_RANGE_COUNT</val>
                <val>1</val>
                <val>1</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp; _target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>target_citys[]</name>
                <type>const struct city *</type>
                <value>{NULL,&amp; _target_city_3}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>target_citys[CPPTEST_DS_GET_UINTEGER("target_citys_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>target_tiles[]</name>
                <type>struct tile *</type>
                <value>{NULL,&amp; _target_tile_5}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>target_citys[CPPTEST_DS_GET_UINTEGER("target_tiles_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>_pow_player</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_MAXTILEUNITS</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.topology_id</name>
                <type/>
                <value>CPPTEST_DS_GET_INTEGER("wld.map.topology_id")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.num_valid_dirs</name>
                <type/>
                <value>CPPTEST_DS_GET_INTEGER("wld.map.num_cardinal_dirs")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.num_cardinal_dirs</name>
                <type/>
                <value>CPPTEST_DS_GET_INTEGER("wld.map.num_cardinal_dirs")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.cardinal_dirs[0]</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.cardinal_dirs[1]</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.xsize</name>
                <type/>
                <value>1</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>{CPPTEST_DS_GET_BOOL("can_player_see_hypotetic_units_at_return_value"),CPPTEST_DS_GET_BOOL("can_player_see_hypotetic_units_at_return_value2")}</P2>
                <P3/>
                <P4/>
            </step>
            <function>can_player_see_hypotetic_units_at</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="4" version="1">
            <step id="StubConfigurationEntryStep" uid="4.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>target_tiles[CPPTEST_DS_GET_INTEGER("map_pos_to_tile_return_value")]</P2>
                <P3/>
                <P4/>
            </step>
            <function>map_pos_to_tile</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="5" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="6" version="1">
            <step id="AssertionStep" uid="6.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
const struct player * _target_player = & _target_player_1;
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * target_citys[] = {NULL,& _target_city_3};
const struct city * _target_city = target_citys[CPPTEST_DS_GET_UINTEGER("target_citys_index_value")];
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
struct tile * target_tiles[] = {NULL,& _target_tile_5};
const struct tile * _target_tile = target_citys[CPPTEST_DS_GET_UINTEGER("target_tiles_index_value")];
struct unit _target_unit_6;
_target_unit_6.owner = _pow_player;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_MAXTILEUNITS;
_req_8.range = CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range");
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value");
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
wld.map.topology_id = CPPTEST_DS_GET_INTEGER("wld.map.topology_id");
wld.map.num_valid_dirs = CPPTEST_DS_GET_INTEGER("wld.map.num_cardinal_dirs");
wld.map.num_cardinal_dirs = CPPTEST_DS_GET_INTEGER("wld.map.num_cardinal_dirs");
wld.map.cardinal_dirs[0] = 1;
wld.map.cardinal_dirs[1] = 1;
wld.map.xsize = 1;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MAXTILEUNITS_1_is_req_active);
CPPTEST_REGISTER_STUB_CALLBACK("can_player_see_hypotetic_units_at", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MAXTILEUNITS_2_can_player_see_hypotetic_units_at);
CPPTEST_REGISTER_STUB_CALLBACK("map_pos_to_tile", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_MAXTILEUNITS_3_map_pos_to_tile);
/* CPPTEST_TC_STEP_UID:5 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:6.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_MAXTILEUNITS */


/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_TERRAIN_et_al */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_TERRAIN_et_al_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_TERRAIN_et_al_2_tile_is_seen(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct tile * target_tile, const struct player * pow_player)
{
   /* CPPTEST_TC_STEP_UID:3.0 */
   *__return = CPPTEST_DS_GET_BOOL("tile_is_seen_return_value");
}
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_TERRAIN_et_al_3_can_player_see_city_internals(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct city * pcity)
{
   /* CPPTEST_TC_STEP_UID:4.0 */
   *__return = CPPTEST_DS_GET_BOOL("tile_is_seen_return_value");
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_TERRAIN_et_al()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.source.kind</val>
                <val>_req_8.range</val>
                <val>target_tiles_index_value</val>
                <val>_req_prob_type_value</val>
                <val>tile_is_seen_return_value</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>VUT_TERRAIN</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_TERRFLAG</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_TERRAINCLASS</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_EXTRA</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_EXTRAFLAG</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_CERTAIN</val>
                <val>false</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>0</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_LOCAL</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_CADJACENT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_ADJACENT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_CITY</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_CITY</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_TRADEROUTE</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_TRADEROUTE</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>true</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_CONTINENT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_PLAYER</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_ALLIANCE</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_TEAM</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_WORLD</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>VUT_BASEFLAG</val>
                <val>REQ_RANGE_COUNT</val>
                <val>1</val>
                <val>RPT_POSSIBLE</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>pow_players[]</name>
                <type>struct player *</type>
                <value>{NULL,&amp; _pow_player_0}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp;_pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp;_target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp;_target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>target_tiles[]</name>
                <type>struct tile *</type>
                <value>{NULL,&amp; _target_tile_5}</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>target_tiles[CPPTEST_DS_GET_UINTEGER("target_tiles_index_value")]</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>_pow_player</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.topology_id</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.num_valid_dirs</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.num_cardinal_dirs</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.cardinal_dirs[0]</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.cardinal_dirs[1]</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.xsize</name>
                <type/>
                <value>1</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("tile_is_seen_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>tile_is_seen</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="4" version="1">
            <step id="StubConfigurationEntryStep" uid="4.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("tile_is_seen_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>can_player_see_city_internals</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="5" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="6" version="1">
            <step id="AssertionStep" uid="6.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
struct player * pow_players[] = {NULL,& _pow_player_0};
const struct player * _pow_player = &_pow_player_0;
struct player _target_player_1;
const struct player * _target_player = &_target_player_1;
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * _target_city = &_target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
struct tile * target_tiles[] = {NULL,& _target_tile_5};
const struct tile * _target_tile = target_tiles[CPPTEST_DS_GET_UINTEGER("target_tiles_index_value")];
struct unit _target_unit_6;
_target_unit_6.owner = _pow_player;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind");
_req_8.range = CPPTEST_DS_GET_ENUM(enum req_range,"_req_8.range");
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = CPPTEST_DS_GET_ENUM(enum req_problem_type,"_req_prob_type_value");
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
wld.map.topology_id = 1;
wld.map.num_valid_dirs = 1;
wld.map.num_cardinal_dirs = 1;
wld.map.cardinal_dirs[0] = 1;
wld.map.cardinal_dirs[1] = 1;
wld.map.xsize = 1;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_TERRAIN_et_al_1_is_req_active);
CPPTEST_REGISTER_STUB_CALLBACK("tile_is_seen", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_TERRAIN_et_al_2_tile_is_seen);
CPPTEST_REGISTER_STUB_CALLBACK("can_player_see_city_internals", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_TERRAIN_et_al_3_can_player_see_city_internals);
/* CPPTEST_TC_STEP_UID:5 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:6.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_TERRAIN_et_al */

/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_ACTION_or_VUT_OTYPE */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTION_or_VUT_OTYPE_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTION_or_VUT_OTYPE()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.source.kind</val>
                <val>_req_8.range</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>VUT_ACTION</val>
                <val>REQ_RANGE_PLAYER</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>VUT_OTYPE</val>
                <val>REQ_RANGE_PLAYER</val>
                <val>TRI_YES</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp;_target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp;_target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>_pow_player</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>REQ_RANGE_PLAYER</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>RPT_CERTAIN</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="3" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="4" version="1">
            <step id="AssertionStep" uid="4.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
const struct player * _target_player = &_target_player_1;
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * _target_city = &_target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
_target_unit_6.owner = _pow_player;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind");
_req_8.range = REQ_RANGE_PLAYER;
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = RPT_CERTAIN;
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_ACTION_or_VUT_OTYPE_1_is_req_active);
/* CPPTEST_TC_STEP_UID:3 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:4.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_ACTION_or_VUT_OTYPE */

/* CPPTEST_TEST_CASE_BEGIN is_req_knowable_test_req_source_kind_VUT_SERVERSETTING */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_SERVERSETTING_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_SERVERSETTING()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>_req_8.source.kind</val>
                <val>_req_8.range</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>VUT_SERVERSETTING</val>
                <val>REQ_RANGE_PLAYER</val>
                <val>TRI_YES</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp;_target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp; _other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp;_target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>_pow_player</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>REQ_RANGE_PLAYER</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>RPT_CERTAIN</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="3" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="4" version="1">
            <step id="AssertionStep" uid="4.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
const struct player * _target_player = &_target_player_1;
struct player _other_player_2;
const struct player * _other_player = & _other_player_2;
struct city _target_city_3;
const struct city * _target_city = &_target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
_target_unit_6.owner = _pow_player;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = CPPTEST_DS_GET_ENUM(enum universals_n,"_req_8.source.kind");
_req_8.range = REQ_RANGE_PLAYER;
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = RPT_CERTAIN;
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_req_knowable_test_req_source_kind_VUT_SERVERSETTING_1_is_req_active);
/* CPPTEST_TC_STEP_UID:3 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:4.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_req_knowable_test_req_source_kind_VUT_SERVERSETTING */

/* CPPTEST_TEST_CASE_BEGIN can_plr_see_all_sym_diplrels_of_test */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_can_plr_see_all_sym_diplrels_of_test_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
void CppTest_StubCallback_metaknowledge_tests_can_plr_see_all_sym_diplrels_of_test_2_player_diplstate_get(CppTest_StubCallInfo* stubCallInfo, struct player_diplstate ** __return, const struct player * plr1, const struct player * plr2)
{
   /* CPPTEST_TC_STEP_UID:3.0 */
   *__return = &diplstate_mock;
}
void CppTest_StubCallback_metaknowledge_tests_can_plr_see_all_sym_diplrels_of_test_3_player_has_embassy(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct player * pplayer2)
{
   /* CPPTEST_TC_STEP_UID:4.0 */
   *__return = CPPTEST_DS_GET_BOOL("_player_has_embassy_stub_return_value");
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_can_plr_see_all_sym_diplrels_of_test()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>pow_players_array_index_value</val>
                <val>_player_has_embassy_stub_return_value</val>
                <val>diplstate_mock.contact_turns_left_value</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>1</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>1</val>
                <val>false</val>
                <val>1</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>1</val>
                <val>false</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; _pow_player_0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp;_target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp;_other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp; _target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp; _target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_DIPLREL</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>REQ_RANGE_PLAYER</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.value.activity</name>
                <type/>
                <value>ACTIVITY_IDLE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>RPT_CERTAIN</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>diplstate_mock.contact_turns_left</name>
                <type/>
                <value>CPPTEST_DS_GET_INTEGER("diplstate_mock.contact_turns_left_value")</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>&amp;diplstate_mock</P2>
                <P3/>
                <P4/>
            </step>
            <function>player_diplstate_get</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="4" version="1">
            <step id="StubConfigurationEntryStep" uid="4.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("_player_has_embassy_stub_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>player_has_embassy</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="5" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="6" version="1">
            <step id="AssertionStep" uid="6.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & _pow_player_0;
struct player _target_player_1;
const struct player * _target_player = &_target_player_1;
struct player _other_player_2;
const struct player * _other_player = &_other_player_2;
struct city _target_city_3;
const struct city * _target_city = & _target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
const struct tile * _target_tile = & _target_tile_5;
struct unit _target_unit_6;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_DIPLREL;
_req_8.range = REQ_RANGE_PLAYER;
_req_8.source.value.activity = ACTIVITY_IDLE;
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = RPT_CERTAIN;
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
diplstate_mock.contact_turns_left = CPPTEST_DS_GET_INTEGER("diplstate_mock.contact_turns_left_value");
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_can_plr_see_all_sym_diplrels_of_test_1_is_req_active);
CPPTEST_REGISTER_STUB_CALLBACK("player_diplstate_get", &CppTest_StubCallback_metaknowledge_tests_can_plr_see_all_sym_diplrels_of_test_2_player_diplstate_get);
CPPTEST_REGISTER_STUB_CALLBACK("player_has_embassy", &CppTest_StubCallback_metaknowledge_tests_can_plr_see_all_sym_diplrels_of_test_3_player_has_embassy);
/* CPPTEST_TC_STEP_UID:5 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:6.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END can_plr_see_all_sym_diplrels_of_test */

/* CPPTEST_TEST_CASE_BEGIN is_tile_seen_cadj_test */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_cadj_test_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_cadj_test_2_tile_is_seen(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct tile * target_tile, const struct player * pow_player)
{
   if (stubCallInfo->callNo == 1){
      /* CPPTEST_TC_STEP_UID:3.0 */
      *__return = CPPTEST_DS_GET_BOOL("tile_is_seen_return_value");
   } else if (stubCallInfo->callNo == 2){
      /* CPPTEST_TC_STEP_UID:3.0 */
      *__return = CPPTEST_DS_GET_BOOL("tile_is_seen_return_value2");
   }
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_cadj_test_3_tile_city(CppTest_StubCallInfo* stubCallInfo, struct city ** __return, const struct tile * ptile)
{
   /* CPPTEST_TC_STEP_UID:4.0 */
   *__return = NULL;
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_cadj_test_4_city_owner(CppTest_StubCallInfo* stubCallInfo, struct player ** __return, const struct city * pcity)
{
   /* CPPTEST_TC_STEP_UID:5.0 */
   *__return = NULL;
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_cadj_test_5_map_pos_to_tile(CppTest_StubCallInfo* stubCallInfo, struct tile ** __return, const struct civ_map * nmap, int x, int y)
{
   /* CPPTEST_TC_STEP_UID:6.0 */
   *__return = target_tiles[CPPTEST_DS_GET_INTEGER("target_tiles_array_index")];
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_tile_seen_cadj_test()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>tile_is_seen_return_value</val>
                <val>wld.map.topology_id</val>
                <val>wld.map.num_cardinal_dirs</val>
                <val>tile_is_seen_return_value2</val>
                <val>target_tiles_array_index</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>false</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>0</val>
                <val>false</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>true</val>
                <val>4</val>
                <val>0</val>
                <val>false</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>0</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>1</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>1</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>1</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>1</val>
                <val>false</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; pow_player_mock</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp;_target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp;_other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp;_target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5.index</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp;_target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>_pow_player</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_TERRAIN</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>REQ_RANGE_CADJACENT</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.value.activity</name>
                <type/>
                <value>ACTIVITY_IDLE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>RPT_POSSIBLE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.topology_id</name>
                <type/>
                <value>CPPTEST_DS_GET_INTEGER("wld.map.topology_id")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.num_cardinal_dirs</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.cardinal_dirs[0]</name>
                <type/>
                <value>CPPTEST_DS_GET_INTEGER("wld.map.num_cardinal_dirs")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.cardinal_dirs[1]</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.xsize</name>
                <type/>
                <value>1</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>{CPPTEST_DS_GET_BOOL("tile_is_seen_return_value"),CPPTEST_DS_GET_BOOL("tile_is_seen_return_value2")}</P2>
                <P3/>
                <P4/>
            </step>
            <function>tile_is_seen</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="4" version="1">
            <step id="StubConfigurationEntryStep" uid="4.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>NULL</P2>
                <P3/>
                <P4/>
            </step>
            <function>tile_city</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="5" version="1">
            <step id="StubConfigurationEntryStep" uid="5.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>NULL</P2>
                <P3/>
                <P4/>
            </step>
            <function>city_owner</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="6" version="1">
            <step id="StubConfigurationEntryStep" uid="6.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>target_tiles[CPPTEST_DS_GET_INTEGER("target_tiles_array_index")]</P2>
                <P3/>
                <P4/>
            </step>
            <function>map_pos_to_tile</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="7" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="8" version="1">
            <step id="AssertionStep" uid="8.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & pow_player_mock;
struct player _target_player_1;
const struct player * _target_player = &_target_player_1;
struct player _other_player_2;
const struct player * _other_player = &_other_player_2;
struct city _target_city_3;
const struct city * _target_city = &_target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
_target_tile_5.index = 1;
const struct tile * _target_tile = &_target_tile_5;
struct unit _target_unit_6;
_target_unit_6.owner = _pow_player;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_TERRAIN;
_req_8.range = REQ_RANGE_CADJACENT;
_req_8.source.value.activity = ACTIVITY_IDLE;
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = RPT_POSSIBLE;
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
wld.map.topology_id = CPPTEST_DS_GET_INTEGER("wld.map.topology_id");
wld.map.num_cardinal_dirs = 1;
wld.map.cardinal_dirs[0] = CPPTEST_DS_GET_INTEGER("wld.map.num_cardinal_dirs");
wld.map.cardinal_dirs[1] = 1;
wld.map.xsize = 1;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_cadj_test_1_is_req_active);
CPPTEST_REGISTER_STUB_CALLBACK("tile_is_seen", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_cadj_test_2_tile_is_seen);
CPPTEST_REGISTER_STUB_CALLBACK("tile_city", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_cadj_test_3_tile_city);
CPPTEST_REGISTER_STUB_CALLBACK("city_owner", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_cadj_test_4_city_owner);
CPPTEST_REGISTER_STUB_CALLBACK("map_pos_to_tile", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_cadj_test_5_map_pos_to_tile);
/* CPPTEST_TC_STEP_UID:7 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:8.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_tile_seen_cadj_test */

/* CPPTEST_TEST_CASE_BEGIN is_tile_seen_adj_test */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_adj_test_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_adj_test_2_tile_is_seen(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct tile * target_tile, const struct player * pow_player)
{
   if (stubCallInfo->callNo == 1){
      /* CPPTEST_TC_STEP_UID:3.0 */
      *__return = CPPTEST_DS_GET_BOOL("tile_is_seen_return_value");
   } else if (stubCallInfo->callNo == 2){
      /* CPPTEST_TC_STEP_UID:3.0 */
      *__return = CPPTEST_DS_GET_BOOL("tile_is_seen_return_value2");
   }
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_adj_test_3_tile_city(CppTest_StubCallInfo* stubCallInfo, struct city ** __return, const struct tile * ptile)
{
   /* CPPTEST_TC_STEP_UID:4.0 */
   *__return = NULL;
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_adj_test_4_city_owner(CppTest_StubCallInfo* stubCallInfo, struct player ** __return, const struct city * pcity)
{
   /* CPPTEST_TC_STEP_UID:5.0 */
   *__return = NULL;
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_adj_test_5_map_pos_to_tile(CppTest_StubCallInfo* stubCallInfo, struct tile ** __return, const struct civ_map * nmap, int x, int y)
{
   /* CPPTEST_TC_STEP_UID:6.0 */
   *__return = target_tiles[CPPTEST_DS_GET_INTEGER("target_tiles_array_index")];
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_tile_seen_adj_test()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>tile_is_seen_return_value</val>
                <val>wld.map.topology_id</val>
                <val>wld.map.num_cardinal_dirs</val>
                <val>tile_is_seen_return_value2</val>
                <val>target_tiles_array_index</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>false</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>0</val>
                <val>false</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>true</val>
                <val>4</val>
                <val>0</val>
                <val>false</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>0</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>1</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>1</val>
                <val>true</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>1</val>
                <val>true</val>
                <val>1</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>1</val>
                <val>false</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; pow_player_mock</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp;_target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp;_other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp;_target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5.index</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp;_target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>_pow_player</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_CITYTILE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>REQ_RANGE_ADJACENT</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.value.activity</name>
                <type/>
                <value>ACTIVITY_IDLE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>RPT_POSSIBLE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.topology_id</name>
                <type/>
                <value>CPPTEST_DS_GET_INTEGER("wld.map.topology_id")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.num_valid_dirs</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.cardinal_dirs[0]</name>
                <type/>
                <value>CPPTEST_DS_GET_INTEGER("wld.map.num_cardinal_dirs")</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.cardinal_dirs[1]</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.map.xsize</name>
                <type/>
                <value>1</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>{CPPTEST_DS_GET_BOOL("tile_is_seen_return_value"),CPPTEST_DS_GET_BOOL("tile_is_seen_return_value2")}</P2>
                <P3/>
                <P4/>
            </step>
            <function>tile_is_seen</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="4" version="1">
            <step id="StubConfigurationEntryStep" uid="4.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>NULL</P2>
                <P3/>
                <P4/>
            </step>
            <function>tile_city</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="5" version="1">
            <step id="StubConfigurationEntryStep" uid="5.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>NULL</P2>
                <P3/>
                <P4/>
            </step>
            <function>city_owner</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="6" version="1">
            <step id="StubConfigurationEntryStep" uid="6.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>target_tiles[CPPTEST_DS_GET_INTEGER("target_tiles_array_index")]</P2>
                <P3/>
                <P4/>
            </step>
            <function>map_pos_to_tile</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="7" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="8" version="1">
            <step id="AssertionStep" uid="8.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & pow_player_mock;
struct player _target_player_1;
const struct player * _target_player = &_target_player_1;
struct player _other_player_2;
const struct player * _other_player = &_other_player_2;
struct city _target_city_3;
const struct city * _target_city = &_target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
_target_tile_5.index = 1;
const struct tile * _target_tile = &_target_tile_5;
struct unit _target_unit_6;
_target_unit_6.owner = _pow_player;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_CITYTILE;
_req_8.range = REQ_RANGE_ADJACENT;
_req_8.source.value.activity = ACTIVITY_IDLE;
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = RPT_POSSIBLE;
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
wld.map.topology_id = CPPTEST_DS_GET_INTEGER("wld.map.topology_id");
wld.map.num_valid_dirs = 1;
wld.map.cardinal_dirs[0] = CPPTEST_DS_GET_INTEGER("wld.map.num_cardinal_dirs");
wld.map.cardinal_dirs[1] = 1;
wld.map.xsize = 1;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_adj_test_1_is_req_active);
CPPTEST_REGISTER_STUB_CALLBACK("tile_is_seen", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_adj_test_2_tile_is_seen);
CPPTEST_REGISTER_STUB_CALLBACK("tile_city", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_adj_test_3_tile_city);
CPPTEST_REGISTER_STUB_CALLBACK("city_owner", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_adj_test_4_city_owner);
CPPTEST_REGISTER_STUB_CALLBACK("map_pos_to_tile", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_adj_test_5_map_pos_to_tile);
/* CPPTEST_TC_STEP_UID:7 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:8.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_tile_seen_adj_test */

/* CPPTEST_TEST_CASE_BEGIN is_tile_seen_city_test */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_city_test_1_can_player_see_city_internals(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct city * pcity)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = CPPTEST_DS_GET_BOOL("can_player_see_city_internals_return_value");
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_city_test_2_city_map_radius_sq_get(CppTest_StubCallInfo* stubCallInfo, int* __return, const struct city * pcity)
{
   if (stubCallInfo->callNo >= 1){
      /* CPPTEST_TC_STEP_UID:3.0 */
      *__return = CPPTEST_DS_GET_INTEGER("city_map_radius_sq_get_return_value");
   }
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_city_test_3_city_tile_index_to_xy(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, int * city_map_x, int * city_map_y, int city_tile_index, int city_radius_sq)
{
   if (stubCallInfo->callNo == 1){
      /* CPPTEST_TC_STEP_UID:4.0 */
      *__return = CPPTEST_DS_GET_BOOL("city_tile_index_to_xy_return_value");
   } else if (stubCallInfo->callNo == 2){
      /* CPPTEST_TC_STEP_UID:4.0 */
      *__return = false;
   }
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_city_test_4_city_map_to_tile(CppTest_StubCallInfo* stubCallInfo, struct tile ** __return, const struct tile * city_center, int city_radius_sq, int city_map_x, int city_map_y)
{
   /* CPPTEST_TC_STEP_UID:5.0 */
   *__return = target_tiles[CPPTEST_DS_GET_INTEGER("target_tiles_array_index")];
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_city_test_5_tile_is_seen(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct tile * target_tile, const struct player * pow_player)
{
   /* CPPTEST_TC_STEP_UID:6.0 */
   *__return = CPPTEST_DS_GET_BOOL("tile_is_seen_return_value");
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_tile_seen_city_test()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>can_player_see_city_internals_return_value</val>
                <val>city_map_radius_sq_get_return_value</val>
                <val>city_tile_index_to_xy_return_value</val>
                <val>target_tiles_array_index</val>
                <val>tile_is_seen_return_value</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>false</val>
                <val>0</val>
                <val>false</val>
                <val>0</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>true</val>
                <val>-2</val>
                <val>false</val>
                <val>0</val>
                <val>false</val>
                <val>TRI_NO</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>false</val>
                <val>0</val>
                <val>false</val>
                <val>TRI_NO</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>true</val>
                <val>0</val>
                <val>true</val>
                <val>TRI_NO</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>true</val>
                <val>1</val>
                <val>true</val>
                <val>TRI_NO</val>
            </row>
            <row>
                <val>true</val>
                <val>0</val>
                <val>true</val>
                <val>1</val>
                <val>false</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; pow_player_mock</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp;_target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp;_other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp;_target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5.index</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp;_target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>_pow_player</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_TERRAIN</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>REQ_RANGE_CITY</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.value.activity</name>
                <type/>
                <value>ACTIVITY_IDLE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>RPT_POSSIBLE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("can_player_see_city_internals_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>can_player_see_city_internals</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>{CPPTEST_DS_GET_INTEGER("city_map_radius_sq_get_return_value"),...}</P2>
                <P3/>
                <P4/>
            </step>
            <function>city_map_radius_sq_get</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="4" version="1">
            <step id="StubConfigurationEntryStep" uid="4.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>{CPPTEST_DS_GET_BOOL("city_tile_index_to_xy_return_value"),false}</P2>
                <P3/>
                <P4/>
            </step>
            <function>city_tile_index_to_xy</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="5" version="1">
            <step id="StubConfigurationEntryStep" uid="5.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>target_tiles[CPPTEST_DS_GET_INTEGER("target_tiles_array_index")]</P2>
                <P3/>
                <P4/>
            </step>
            <function>city_map_to_tile</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="6" version="1">
            <step id="StubConfigurationEntryStep" uid="6.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>CPPTEST_DS_GET_BOOL("tile_is_seen_return_value")</P2>
                <P3/>
                <P4/>
            </step>
            <function>tile_is_seen</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="7" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="8" version="1">
            <step id="AssertionStep" uid="8.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & pow_player_mock;
struct player _target_player_1;
const struct player * _target_player = &_target_player_1;
struct player _other_player_2;
const struct player * _other_player = &_other_player_2;
struct city _target_city_3;
const struct city * _target_city = &_target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
_target_tile_5.index = 1;
const struct tile * _target_tile = &_target_tile_5;
struct unit _target_unit_6;
_target_unit_6.owner = _pow_player;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_TERRAIN;
_req_8.range = REQ_RANGE_CITY;
_req_8.source.value.activity = ACTIVITY_IDLE;
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = RPT_POSSIBLE;
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("can_player_see_city_internals", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_city_test_1_can_player_see_city_internals);
CPPTEST_REGISTER_STUB_CALLBACK("city_map_radius_sq_get", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_city_test_2_city_map_radius_sq_get);
CPPTEST_REGISTER_STUB_CALLBACK("city_tile_index_to_xy", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_city_test_3_city_tile_index_to_xy);
CPPTEST_REGISTER_STUB_CALLBACK("city_map_to_tile", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_city_test_4_city_map_to_tile);
CPPTEST_REGISTER_STUB_CALLBACK("tile_is_seen", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_city_test_5_tile_is_seen);
/* CPPTEST_TC_STEP_UID:7 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:8.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_tile_seen_city_test */

/* CPPTEST_TEST_CASE_BEGIN is_tile_seen_traderoute_test */
/* CPPTEST_TEST_CASE_CONTEXT _Bool is_tile_seen_traderoute(const struct player *, const struct city *) */
/* CPPTEST_TEST_CASE_CALLBACKS_BEGIN */
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_traderoute_test_1_is_req_active(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * target_player, const struct player * other_player, const struct city * target_city, const struct impr_type * target_building, const struct tile * target_tile, const struct unit * target_unit, const struct unit_type * target_unittype, const struct output_type * target_output, const struct specialist * target_specialist, const struct action * target_action, const struct requirement * req, const enum req_problem_type prob_type)
{
   /* CPPTEST_TC_STEP_UID:2.0 */
   *__return = true;
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_traderoute_test_2_can_player_see_city_internals(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct player * pplayer, const struct city * pcity)
{
   if (stubCallInfo->callNo == 1){
      /* CPPTEST_TC_STEP_UID:3.0 */
      *__return = CPPTEST_DS_GET_BOOL("can_player_see_city_internals_return_value");
   } else if (stubCallInfo->callNo == 2){
      /* CPPTEST_TC_STEP_UID:3.0 */
      *__return = CPPTEST_DS_GET_BOOL("can_player_see_city_internals_return_value2");
   } else if (stubCallInfo->callNo == 3){
      /* CPPTEST_TC_STEP_UID:3.0 */
      *__return = CPPTEST_DS_GET_BOOL("can_player_see_city_internals_return_value3");
   }
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_traderoute_test_3_tile_is_seen(CppTest_StubCallInfo* stubCallInfo, _Bool* __return, const struct tile * target_tile, const struct player * pow_player)
{
   if (stubCallInfo->callNo == 1){
      /* CPPTEST_TC_STEP_UID:4.0 */
      *__return = CPPTEST_DS_GET_BOOL("tile_is_seen_return_value");
   } else if (stubCallInfo->callNo == 2){
      /* CPPTEST_TC_STEP_UID:4.0 */
      *__return = CPPTEST_DS_GET_BOOL("tile_is_seen_return_value2");
   }
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_traderoute_test_4_genlist_head(CppTest_StubCallInfo* stubCallInfo, struct genlist_link ** __return, const struct genlist * pgenlist)
{
   /* CPPTEST_TC_STEP_UID:5.0 */
   *__return = proute_iters[CPPTEST_DS_GET_INTEGER("proute_iters_array_index")];
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_traderoute_test_5_genlist_link_next(CppTest_StubCallInfo* stubCallInfo, struct genlist_link ** __return, const struct genlist_link * plink)
{
   if (stubCallInfo->callNo == 1){
      /* CPPTEST_TC_STEP_UID:6.0 */
      *__return = proute_iters[CPPTEST_DS_GET_INTEGER("proute_iters_array_index2")];
   } else if (stubCallInfo->callNo == 2){
      /* CPPTEST_TC_STEP_UID:6.0 */
      *__return = NULL;
   }
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_traderoute_test_6_genlist_link_data(CppTest_StubCallInfo* stubCallInfo, void ** __return, const struct genlist_link * plink)
{
   /* CPPTEST_TC_STEP_UID:7.0 */
   *__return = &proute_mock;
}
void CppTest_StubCallback_metaknowledge_tests_is_tile_seen_traderoute_test_7_game_city_by_number(CppTest_StubCallInfo* stubCallInfo, struct city ** __return, int id)
{
   /* CPPTEST_TC_STEP_UID:8.0 */
   *__return = NULL;
}
/* CPPTEST_TEST_CASE_CALLBACKS_END */
void metaknowledge_tests_is_tile_seen_traderoute_test()
{
/* CPPTEST_TEST_CASE_DATA_BEGIN */
#if 0

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testcase>
    <metadata/>
    <steps>
        <step id="DataSourceStep" uid="0" version="2">
            <row>
                <val>can_player_see_city_internals_return_value</val>
                <val>can_player_see_city_internals_return_value2</val>
                <val>can_player_see_city_internals_return_value3</val>
                <val>tile_is_seen_return_value</val>
                <val>tile_is_seen_return_value2</val>
                <val>proute_iters_array_index</val>
                <val>proute_iters_array_index2</val>
                <val>_return_test_val</val>
            </row>
            <row>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>true</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>true</val>
                <val>true</val>
                <val>false</val>
                <val>true</val>
                <val>false</val>
                <val>0</val>
                <val>0</val>
                <val>TRI_YES</val>
            </row>
            <row>
                <val>true</val>
                <val>true</val>
                <val>false</val>
                <val>true</val>
                <val>false</val>
                <val>1</val>
                <val>0</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>true</val>
                <val>true</val>
                <val>true</val>
                <val>true</val>
                <val>false</val>
                <val>1</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <row>
                <val>true</val>
                <val>true</val>
                <val>true</val>
                <val>true</val>
                <val>true</val>
                <val>1</val>
                <val>1</val>
                <val>TRI_MAYBE</val>
            </row>
            <ext>false</ext>
            <extname/>
        </step>
        <step id="MultiVariableStep" uid="1" version="1">
            <step id="VariableStep" version="1">
                <name>_pow_player_0</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_pow_player</name>
                <type>const struct player *</type>
                <value>&amp; pow_player_mock</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player_1</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_player</name>
                <type>const struct player *</type>
                <value>&amp;_target_player_1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player_2</name>
                <type>struct player</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_other_player</name>
                <type>const struct player *</type>
                <value>&amp;_other_player_2</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city_3</name>
                <type>struct city</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_city</name>
                <type>const struct city *</type>
                <value>&amp;_target_city_3</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building_4</name>
                <type>struct impr_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_building</name>
                <type>const struct impr_type *</type>
                <value>&amp; _target_building_4</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5</name>
                <type>struct tile</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile_5.index</name>
                <type/>
                <value>1</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_tile</name>
                <type>const struct tile *</type>
                <value>&amp;_target_tile_5</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6</name>
                <type>struct unit</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit_6.owner</name>
                <type/>
                <value>_pow_player</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_unit</name>
                <type>const struct unit *</type>
                <value>&amp;_target_unit_6</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output_7</name>
                <type>struct output_type</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_output</name>
                <type>const struct output_type *</type>
                <value>&amp; _target_output_7</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_target_specialist</name>
                <type>const struct specialist *</type>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8</name>
                <type>struct requirement</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.kind</name>
                <type/>
                <value>VUT_TERRAIN</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.range</name>
                <type/>
                <value>REQ_RANGE_TRADEROUTE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req_8.source.value.activity</name>
                <type/>
                <value>ACTIVITY_IDLE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_req</name>
                <type>const struct requirement *</type>
                <value>&amp; _req_8</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_prob_type</name>
                <type>enum req_problem_type</type>
                <value>RPT_POSSIBLE</value>
            </step>
            <step id="VariableStep" version="1">
                <name>_return</name>
                <type>enum fc_tristate</type>
                <value/>
            </step>
            <step id="VariableStep" version="1">
                <name>nologmsg</name>
                <type/>
                <value>"stub_message:%s"</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.cities</name>
                <type/>
                <value>0</value>
            </step>
            <step id="VariableStep" version="1">
                <name>wld.units</name>
                <type/>
                <value>0</value>
            </step>
        </step>
        <step id="StubConfigurationStep" uid="2" version="1">
            <step id="StubConfigurationEntryStep" uid="2.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>true</P2>
                <P3/>
                <P4/>
            </step>
            <function>is_req_active</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="3" version="1">
            <step id="StubConfigurationEntryStep" uid="3.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>{CPPTEST_DS_GET_BOOL("can_player_see_city_internals_return_value"),CPPTEST_DS_GET_BOOL("can_player_see_city_internals_return_value2"),CPPTEST_DS_GET_BOOL("can_player_see_city_internals_return_value3")}</P2>
                <P3/>
                <P4/>
            </step>
            <function>can_player_see_city_internals</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="4" version="1">
            <step id="StubConfigurationEntryStep" uid="4.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>{CPPTEST_DS_GET_BOOL("tile_is_seen_return_value"),CPPTEST_DS_GET_BOOL("tile_is_seen_return_value2")}</P2>
                <P3/>
                <P4/>
            </step>
            <function>tile_is_seen</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="5" version="1">
            <step id="StubConfigurationEntryStep" uid="5.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>proute_iters[CPPTEST_DS_GET_INTEGER("proute_iters_array_index")]</P2>
                <P3/>
                <P4/>
            </step>
            <function>genlist_head</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="6" version="1">
            <step id="StubConfigurationEntryStep" uid="6.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>{proute_iters[CPPTEST_DS_GET_INTEGER("proute_iters_array_index2")],NULL}</P2>
                <P3/>
                <P4/>
            </step>
            <function>genlist_link_next</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="7" version="1">
            <step id="StubConfigurationEntryStep" uid="7.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>&amp;proute_mock</P2>
                <P3/>
                <P4/>
            </step>
            <function>genlist_link_data</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="StubConfigurationStep" uid="8" version="1">
            <step id="StubConfigurationEntryStep" uid="8.0" version="1">
                <action>SET VALUE</action>
                <P1>*__return</P1>
                <P2>NULL</P2>
                <P3/>
                <P4/>
            </step>
            <function>game_city_by_number</function>
            <code><![CDATA[//To access current call number use: 'stubCallInfo->callNo']]></code>
            <mode>table</mode>
        </step>
        <step id="CallStep" uid="9" version="1">
            <comment>Tested function call</comment>
            <return>_return</return>
            <name>mke_eval_req</name>
            <params>_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type</params>
        </step>
        <step id="AssertionsStep" uid="10" version="1">
            <step id="AssertionStep" uid="10.0" version="1">
                <type>CPPTEST_ASSERT_ENUM_EQUAL</type>
                <P1>enum fc_tristate</P1>
                <P2>CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val")</P2>
                <P3>_return</P3>
                <P4/>
            </step>
        </step>
    </steps>
</testcase>

#endif
/* CPPTEST_TEST_CASE_DATA_END */
struct player _pow_player_0;
const struct player * _pow_player = & pow_player_mock;
struct player _target_player_1;
const struct player * _target_player = &_target_player_1;
struct player _other_player_2;
const struct player * _other_player = &_other_player_2;
struct city _target_city_3;
const struct city * _target_city = &_target_city_3;
struct impr_type _target_building_4;
const struct impr_type * _target_building = & _target_building_4;
struct tile _target_tile_5;
_target_tile_5.index = 1;
const struct tile * _target_tile = &_target_tile_5;
struct unit _target_unit_6;
_target_unit_6.owner = _pow_player;
const struct unit * _target_unit = &_target_unit_6;
struct output_type _target_output_7;
const struct output_type * _target_output = & _target_output_7;
const struct specialist * _target_specialist = 0;
struct requirement _req_8;
_req_8.source.kind = VUT_TERRAIN;
_req_8.range = REQ_RANGE_TRADEROUTE;
_req_8.source.value.activity = ACTIVITY_IDLE;
const struct requirement * _req = & _req_8;
enum req_problem_type _prob_type = RPT_POSSIBLE;
enum fc_tristate _return;
nologmsg = "stub_message:%s";
wld.cities = 0;
wld.units = 0;
CPPTEST_REGISTER_STUB_CALLBACK("is_req_active", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_traderoute_test_1_is_req_active);
CPPTEST_REGISTER_STUB_CALLBACK("can_player_see_city_internals", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_traderoute_test_2_can_player_see_city_internals);
CPPTEST_REGISTER_STUB_CALLBACK("tile_is_seen", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_traderoute_test_3_tile_is_seen);
CPPTEST_REGISTER_STUB_CALLBACK("genlist_head", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_traderoute_test_4_genlist_head);
CPPTEST_REGISTER_STUB_CALLBACK("genlist_link_next", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_traderoute_test_5_genlist_link_next);
CPPTEST_REGISTER_STUB_CALLBACK("genlist_link_data", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_traderoute_test_6_genlist_link_data);
CPPTEST_REGISTER_STUB_CALLBACK("game_city_by_number", &CppTest_StubCallback_metaknowledge_tests_is_tile_seen_traderoute_test_7_game_city_by_number);
/* CPPTEST_TC_STEP_UID:9 */
_return = mke_eval_req(_pow_player, _target_player, _other_player, _target_city, _target_building, _target_tile, _target_unit, _target_output, _target_specialist, _req, _prob_type);
/* CPPTEST_TC_STEP_UID:10.0 */
CPPTEST_ASSERT_ENUM_EQUAL(enum fc_tristate, CPPTEST_DS_GET_ENUM(enum fc_tristate,"_return_test_val"), _return);
}
/* CPPTEST_TEST_CASE_END is_tile_seen_traderoute_test */
